"use strict";Object.defineProperty(exports, "__esModule", {value: true});// src/index.ts
var _edgeconfigfs = require('@vercel/edge-config-fs');

// package.json
var name = "@vercel/edge-config";
var version = "1.1.1";

// src/utils/tracing.ts
var edgeConfigTraceSymbol = Symbol.for("@vercel/edge-config:global-trace");
function setTracerProvider(tracer) {
  Reflect.set(globalThis, edgeConfigTraceSymbol, tracer);
}
function getTracer() {
  const maybeTraceApi = Reflect.get(globalThis, edgeConfigTraceSymbol);
  return maybeTraceApi == null ? void 0 : maybeTraceApi.getTracer(name, version);
}
function isPromise(p) {
  return p !== null && typeof p === "object" && "then" in p && typeof p.then === "function";
}
function trace(fn, options = {
  name: fn.name
}) {
  const traced = function(...args) {
    const tracer = getTracer();
    if (!tracer)
      return fn.apply(this, args);
    const shouldTrace = process.env.EDGE_CONFIG_TRACE_VERBOSE === "true" || options.isVerboseTrace === false;
    if (!shouldTrace)
      return fn.apply(this, args);
    return tracer.startActiveSpan(options.name, (span) => {
      if (options.attributes)
        span.setAttributes(options.attributes);
      try {
        const result = fn.apply(this, args);
        if (isPromise(result)) {
          result.then((value) => {
            if (options.attributesSuccess) {
              span.setAttributes(
                options.attributesSuccess(
                  value
                )
              );
            }
            span.setStatus({ code: 1 });
            span.end();
          }).catch((error) => {
            if (options.attributesError) {
              span.setAttributes(options.attributesError(error));
            }
            span.setStatus({
              code: 2,
              // 2 = Error
              message: error instanceof Error ? error.message : void 0
            });
            span.end();
          });
        } else {
          if (options.attributesSuccess) {
            span.setAttributes(options.attributesSuccess(result));
          }
          span.setStatus({ code: 1 });
          span.end();
        }
        return result;
      } catch (error) {
        if (options.attributesError) {
          span.setAttributes(options.attributesError(error));
        }
        span.setStatus({
          code: 2,
          // 2 = Error
          message: error instanceof Error ? error.message : void 0
        });
        span.end();
        throw error;
      }
    });
  };
  return traced;
}

// src/utils/index.ts
var ERRORS = {
  UNAUTHORIZED: "@vercel/edge-config: Unauthorized",
  EDGE_CONFIG_NOT_FOUND: "@vercel/edge-config: Edge Config not found"
};
var UnexpectedNetworkError = class extends Error {
  constructor(res) {
    super(
      `@vercel/edge-config: Unexpected error due to response with status code ${res.status}`
    );
  }
};
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function pick(obj, keys) {
  const ret = {};
  keys.forEach((key) => {
    ret[key] = obj[key];
  });
  return ret;
}
function assertIsKey(key) {
  if (typeof key !== "string") {
    throw new Error("@vercel/edge-config: Expected key to be a string");
  }
}
function assertIsKeys(keys) {
  if (!Array.isArray(keys) || keys.some((key) => typeof key !== "string")) {
    throw new Error(
      "@vercel/edge-config: Expected keys to be an array of string"
    );
  }
}
var clone = trace(
  function clone2(value) {
    if (typeof structuredClone === "function")
      return structuredClone(value);
    if (value === void 0)
      return value;
    return JSON.parse(JSON.stringify(value));
  },
  { name: "clone" }
);
function parseVercelConnectionString(text) {
  try {
    const url = new URL(text);
    if (url.host !== "edge-config.vercel.com")
      return null;
    if (url.protocol !== "https:")
      return null;
    if (!url.pathname.startsWith("/ecfg"))
      return null;
    const id = url.pathname.split("/")[1];
    if (!id)
      return null;
    const token = url.searchParams.get("token");
    if (!token || token === "")
      return null;
    return {
      type: "vercel",
      baseUrl: `https://edge-config.vercel.com/${id}`,
      id,
      version: "1",
      token
    };
  } catch (e) {
    return null;
  }
}
function parseExternalConnectionString(connectionString) {
  try {
    const url = new URL(connectionString);
    let id = url.searchParams.get("id");
    const token = url.searchParams.get("token");
    const version2 = url.searchParams.get("version") || "1";
    if (!id || url.pathname.startsWith("/ecfg_")) {
      id = url.pathname.split("/")[1] || null;
    }
    if (!id || !token)
      return null;
    url.search = "";
    return {
      type: "external",
      baseUrl: url.toString(),
      id,
      token,
      version: version2
    };
  } catch (e2) {
    return null;
  }
}
function parseConnectionString(connectionString) {
  const connection = parseVercelConnectionString(connectionString);
  if (connection)
    return connection;
  return parseExternalConnectionString(connectionString);
}

// src/utils/fetch-with-cached-response.ts
function createResponse(cachedResponseEntry) {
  return new Response(cachedResponseEntry.response, {
    headers: {
      ...cachedResponseEntry.headers,
      Age: String(
        // age header may not be 0 when serving stale content, must be >= 1
        Math.max(1, Math.floor((Date.now() - cachedResponseEntry.time) / 1e3))
      )
    },
    status: cachedResponseEntry.status
  });
}
function createHandleStaleIfError(cachedResponseEntry, staleIfError) {
  return function handleStaleIfError(response) {
    switch (response.status) {
      case 500:
      case 502:
      case 503:
      case 504:
        return typeof staleIfError === "number" && cachedResponseEntry.time < Date.now() + staleIfError * 1e3 ? createResponse(cachedResponseEntry) : response;
      default:
        return response;
    }
  };
}
function createHandleStaleIfErrorException(cachedResponseEntry, staleIfError) {
  return function handleStaleIfError(reason) {
    if (typeof staleIfError === "number" && cachedResponseEntry.time < Date.now() + staleIfError * 1e3) {
      return createResponse(cachedResponseEntry);
    }
    throw reason;
  };
}
var cache = /* @__PURE__ */ new Map();
function extractStaleIfError(cacheControlHeader) {
  if (!cacheControlHeader)
    return null;
  const matched = /stale-if-error=(?<staleIfError>\d+)/i.exec(
    cacheControlHeader
  );
  return (matched == null ? void 0 : matched.groups) ? Number(matched.groups.staleIfError) : null;
}
var fetchWithCachedResponse = trace(
  async function fetchWithCachedResponse2(url, options = {}) {
    const { headers: customHeaders = new Headers(), ...customOptions } = options;
    const authHeader = customHeaders.get("Authorization");
    const cacheKey = `${url},${authHeader || ""}`;
    const cachedResponseEntry = cache.get(cacheKey);
    if (cachedResponseEntry) {
      const { etag: etag2, response: cachedResponse } = cachedResponseEntry;
      const headers = new Headers(customHeaders);
      headers.set("If-None-Match", etag2);
      const staleIfError = extractStaleIfError(headers.get("Cache-Control"));
      const res2 = await fetch(url, {
        ...customOptions,
        headers
      }).then(
        createHandleStaleIfError(cachedResponseEntry, staleIfError),
        createHandleStaleIfErrorException(cachedResponseEntry, staleIfError)
      );
      if (res2.status === 304) {
        res2.cachedResponseBody = JSON.parse(cachedResponse);
        return res2;
      }
      const newETag = res2.headers.get("ETag");
      if (res2.ok && newETag)
        cache.set(cacheKey, {
          etag: newETag,
          response: await res2.clone().text(),
          headers: Object.fromEntries(res2.headers.entries()),
          status: res2.status,
          time: Date.now()
        });
      return res2;
    }
    const res = await fetch(url, options);
    const etag = res.headers.get("ETag");
    if (res.ok && etag) {
      cache.set(cacheKey, {
        etag,
        response: await res.clone().text(),
        headers: Object.fromEntries(res.headers.entries()),
        status: res.status,
        time: Date.now()
      });
    }
    return res;
  },
  {
    name: "fetchWithCachedResponse",
    attributesSuccess(result) {
      return {
        status: result.status
      };
    }
  }
);

// src/index.ts
var jsonParseCache = /* @__PURE__ */ new Map();
var readFileTraced = trace(_edgeconfigfs.readFile, { name: "readFile" });
var jsonParseTraced = trace(JSON.parse, { name: "JSON.parse" });
var privateEdgeConfigSymbol = Symbol.for("privateEdgeConfig");
var cachedJsonParseTraced = trace(
  (edgeConfigId, content) => {
    const cached = jsonParseCache.get(edgeConfigId);
    if (cached)
      return cached;
    const parsed = jsonParseTraced(content);
    jsonParseCache.set(edgeConfigId, Object.freeze(parsed));
    return parsed;
  },
  { name: "cached JSON.parse" }
);
var getFileSystemEdgeConfig = trace(
  async function getFileSystemEdgeConfig2(connection) {
    if (connection.type !== "vercel")
      return null;
    if (!process.env.AWS_LAMBDA_FUNCTION_NAME)
      return null;
    try {
      const content = await readFileTraced(
        `/opt/edge-config/${connection.id}.json`,
        "utf-8"
      );
      return cachedJsonParseTraced(
        connection.id,
        content
      );
    } catch (e3) {
      return null;
    }
  },
  {
    name: "getFileSystemEdgeConfig"
  }
);
var getPrivateEdgeConfig = trace(
  async function getPrivateEdgeConfig2(connection) {
    const privateEdgeConfig = Reflect.get(
      globalThis,
      privateEdgeConfigSymbol
    );
    if (typeof privateEdgeConfig === "object" && typeof privateEdgeConfig.get === "function") {
      return privateEdgeConfig.get(connection.id);
    }
    return null;
  },
  {
    name: "getPrivateEdgeConfig"
  }
);
function createGetInMemoryEdgeConfig(shouldUseDevelopmentCache, connection, headers) {
  let embeddedEdgeConfigPromise = null;
  let latestRequest = null;
  return trace(
    () => {
      if (!shouldUseDevelopmentCache)
        return Promise.resolve(null);
      if (!latestRequest) {
        latestRequest = fetchWithCachedResponse(
          `${connection.baseUrl}/items?version=${connection.version}`,
          {
            headers: new Headers(headers),
            cache: "no-store"
          }
        ).then(async (res) => {
          const digest2 = res.headers.get("x-edge-config-digest");
          let body;
          if (!res.ok) {
            await consumeResponseBody(res);
            body = res.cachedResponseBody;
            if (!body)
              return null;
          } else {
            body = await res.json();
          }
          return { digest: digest2, items: body };
        });
        latestRequest.then(
          (resolved) => {
            embeddedEdgeConfigPromise = Promise.resolve(resolved);
            latestRequest = null;
          },
          // Attach a `.catch` handler to this promise so that if it does throw,
          // we don't get an unhandled promise rejection event. We unset the
          // `latestRequest` so that the next call will make a new request.
          () => {
            embeddedEdgeConfigPromise = null;
            latestRequest = null;
          }
        );
      }
      if (!embeddedEdgeConfigPromise) {
        embeddedEdgeConfigPromise = latestRequest;
      }
      return embeddedEdgeConfigPromise;
    },
    {
      name: "getInMemoryEdgeConfig"
    }
  );
}
async function getLocalEdgeConfig(connection) {
  const edgeConfig = await getPrivateEdgeConfig(connection) || await getFileSystemEdgeConfig(connection);
  return edgeConfig;
}
async function consumeResponseBody(res) {
  await res.arrayBuffer();
}
var createClient = trace(
  function createClient2(connectionString, options = {
    staleIfError: 604800
    /* one week */
  }) {
    if (!connectionString)
      throw new Error("@vercel/edge-config: No connection string provided");
    const connection = parseConnectionString(connectionString);
    if (!connection)
      throw new Error(
        "@vercel/edge-config: Invalid connection string provided"
      );
    const edgeConfigId = connection.id;
    const baseUrl = connection.baseUrl;
    const version2 = connection.version;
    const headers = {
      Authorization: `Bearer ${connection.token}`
    };
    if (typeof process !== "undefined" && process.env.VERCEL_ENV)
      headers["x-edge-config-vercel-env"] = process.env.VERCEL_ENV;
    if (typeof name === "string" && typeof version === "string")
      headers["x-edge-config-sdk"] = `${name}@${version}`;
    if (typeof options.staleIfError === "number" && options.staleIfError > 0)
      headers["cache-control"] = `stale-if-error=${options.staleIfError}`;
    const shouldUseDevelopmentCache = !options.disableDevelopmentCache && process.env.NODE_ENV === "development" && process.env.EDGE_CONFIG_DISABLE_DEVELOPMENT_SWR !== "1";
    const getInMemoryEdgeConfig = createGetInMemoryEdgeConfig(
      shouldUseDevelopmentCache,
      connection,
      headers
    );
    const api = {
      get: trace(
        async function get2(key) {
          const localEdgeConfig = await getInMemoryEdgeConfig() || await getLocalEdgeConfig(connection);
          if (localEdgeConfig) {
            assertIsKey(key);
            return Promise.resolve(
              localEdgeConfig.items[key]
            );
          }
          assertIsKey(key);
          return fetchWithCachedResponse(
            `${baseUrl}/item/${key}?version=${version2}`,
            {
              headers: new Headers(headers),
              cache: "no-store"
            }
          ).then(async (res) => {
            if (res.ok)
              return res.json();
            await consumeResponseBody(res);
            if (res.status === 401)
              throw new Error(ERRORS.UNAUTHORIZED);
            if (res.status === 404) {
              if (res.headers.has("x-edge-config-digest"))
                return void 0;
              throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);
            }
            if (res.cachedResponseBody !== void 0)
              return res.cachedResponseBody;
            throw new UnexpectedNetworkError(res);
          });
        },
        { name: "get", isVerboseTrace: false, attributes: { edgeConfigId } }
      ),
      has: trace(
        async function has2(key) {
          const localEdgeConfig = await getInMemoryEdgeConfig() || await getLocalEdgeConfig(connection);
          if (localEdgeConfig) {
            assertIsKey(key);
            return Promise.resolve(hasOwnProperty(localEdgeConfig.items, key));
          }
          assertIsKey(key);
          return fetch(`${baseUrl}/item/${key}?version=${version2}`, {
            method: "HEAD",
            headers: new Headers(headers),
            cache: "no-store"
          }).then((res) => {
            if (res.status === 401)
              throw new Error(ERRORS.UNAUTHORIZED);
            if (res.status === 404) {
              if (res.headers.has("x-edge-config-digest"))
                return false;
              throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);
            }
            if (res.ok)
              return true;
            throw new UnexpectedNetworkError(res);
          });
        },
        { name: "has", isVerboseTrace: false, attributes: { edgeConfigId } }
      ),
      getAll: trace(
        async function getAll2(keys) {
          const localEdgeConfig = await getInMemoryEdgeConfig() || await getLocalEdgeConfig(connection);
          if (localEdgeConfig) {
            if (keys === void 0) {
              return Promise.resolve(localEdgeConfig.items);
            }
            assertIsKeys(keys);
            return Promise.resolve(
              pick(localEdgeConfig.items, keys)
            );
          }
          if (Array.isArray(keys))
            assertIsKeys(keys);
          const search = Array.isArray(keys) ? new URLSearchParams(
            keys.map((key) => ["key", key])
          ).toString() : null;
          if (search === "")
            return Promise.resolve({});
          return fetchWithCachedResponse(
            `${baseUrl}/items?version=${version2}${search === null ? "" : `&${search}`}`,
            {
              headers: new Headers(headers),
              cache: "no-store"
            }
          ).then(async (res) => {
            if (res.ok)
              return res.json();
            await consumeResponseBody(res);
            if (res.status === 401)
              throw new Error(ERRORS.UNAUTHORIZED);
            if (res.status === 404)
              throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);
            if (res.cachedResponseBody !== void 0)
              return res.cachedResponseBody;
            throw new UnexpectedNetworkError(res);
          });
        },
        { name: "getAll", isVerboseTrace: false, attributes: { edgeConfigId } }
      ),
      digest: trace(
        async function digest2() {
          const localEdgeConfig = await getInMemoryEdgeConfig() || await getLocalEdgeConfig(connection);
          if (localEdgeConfig) {
            return Promise.resolve(localEdgeConfig.digest);
          }
          return fetchWithCachedResponse(
            `${baseUrl}/digest?version=${version2}`,
            {
              headers: new Headers(headers),
              cache: "no-store"
            }
          ).then(async (res) => {
            if (res.ok)
              return res.json();
            await consumeResponseBody(res);
            if (res.cachedResponseBody !== void 0)
              return res.cachedResponseBody;
            throw new UnexpectedNetworkError(res);
          });
        },
        { name: "digest", isVerboseTrace: false, attributes: { edgeConfigId } }
      )
    };
    return { ...api, connection };
  },
  {
    name: "createClient"
  }
);
var defaultEdgeConfigClient;
function init() {
  if (!defaultEdgeConfigClient) {
    defaultEdgeConfigClient = createClient(process.env.EDGE_CONFIG);
  }
}
var get = (...args) => {
  init();
  return defaultEdgeConfigClient.get(...args);
};
var getAll = (...args) => {
  init();
  return defaultEdgeConfigClient.getAll(...args);
};
var has = (...args) => {
  init();
  return defaultEdgeConfigClient.has(...args);
};
var digest = (...args) => {
  init();
  return defaultEdgeConfigClient.digest(...args);
};
function clone3(edgeConfigValue) {
  return JSON.parse(JSON.stringify(edgeConfigValue));
}









exports.clone = clone3; exports.createClient = createClient; exports.digest = digest; exports.get = get; exports.getAll = getAll; exports.has = has; exports.parseConnectionString = parseConnectionString; exports.setTracerProvider = setTracerProvider;
//# sourceMappingURL=index.cjs.map
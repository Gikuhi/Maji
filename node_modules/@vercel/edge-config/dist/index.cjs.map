{"version":3,"sources":["../src/index.ts","../package.json","../src/utils/tracing.ts","../src/utils/index.ts","../src/utils/fetch-with-cached-response.ts"],"names":["clone","version","fetchWithCachedResponse","etag","res","getFileSystemEdgeConfig","getPrivateEdgeConfig","digest","createClient","get","has","getAll"],"mappings":";AAAA,SAAS,gBAAgB;;;ACCvB,WAAQ;AACR,cAAW;;;ACGb,IAAM,wBAAwB,OAAO,IAAI,kCAAkC;AAMpE,SAAS,kBAAkB,QAA8B;AAC9D,UAAQ,IAAI,YAAY,uBAAuB,MAAM;AACvD;AAEA,SAAS,YAAgC;AACvC,QAAM,gBAAgB,QAAQ,IAAI,YAAY,qBAAqB;AAGnE,SAAO,+CAAe,UAAU,MAAS;AAC3C;AAEA,SAAS,UAAa,GAA6B;AACjD,SACE,MAAM,QACN,OAAO,MAAM,YACb,UAAU,KACV,OAAO,EAAE,SAAS;AAEtB;AAGO,SAAS,MACd,IACA,UASI;AAAA,EACF,MAAM,GAAG;AACX,GACG;AACH,QAAM,SAAS,YAA4B,MAA0B;AACnE,UAAM,SAAS,UAAU;AACzB,QAAI,CAAC;AAAQ,aAAO,GAAG,MAAM,MAAM,IAAI;AAEvC,UAAM,cACJ,QAAQ,IAAI,8BAA8B,UAC1C,QAAQ,mBAAmB;AAC7B,QAAI,CAAC;AAAa,aAAO,GAAG,MAAM,MAAM,IAAI;AAE5C,WAAO,OAAO,gBAAgB,QAAQ,MAAM,CAAC,SAAS;AACpD,UAAI,QAAQ;AAAY,aAAK,cAAc,QAAQ,UAAU;AAE7D,UAAI;AACF,cAAM,SAAS,GAAG,MAAM,MAAM,IAAI;AAElC,YAAI,UAAU,MAAM,GAAG;AACrB,iBACG,KAAK,CAAC,UAAU;AACf,gBAAI,QAAQ,mBAAmB;AAC7B,mBAAK;AAAA,gBACH,QAAQ;AAAA,kBACN;AAAA,gBAGF;AAAA,cACF;AAAA,YACF;AAEA,iBAAK,UAAU,EAAE,MAAM,EAAE,CAAC;AAC1B,iBAAK,IAAI;AAAA,UACX,CAAC,EACA,MAAM,CAAC,UAAU;AAChB,gBAAI,QAAQ,iBAAiB;AAE3B,mBAAK,cAAc,QAAQ,gBAAgB,KAAK,CAAC;AAAA,YACnD;AAEA,iBAAK,UAAU;AAAA,cACb,MAAM;AAAA;AAAA,cACN,SAAS,iBAAiB,QAAQ,MAAM,UAAU;AAAA,YACpD,CAAC;AAED,iBAAK,IAAI;AAAA,UACX,CAAC;AAAA,QACL,OAAO;AACL,cAAI,QAAQ,mBAAmB;AAE7B,iBAAK,cAAc,QAAQ,kBAAkB,MAAM,CAAC;AAAA,UACtD;AAEA,eAAK,UAAU,EAAE,MAAM,EAAE,CAAC;AAC1B,eAAK,IAAI;AAAA,QACX;AAEA,eAAO;AAAA,MACT,SAAS,OAAY;AACnB,YAAI,QAAQ,iBAAiB;AAC3B,eAAK,cAAc,QAAQ,gBAAgB,KAAc,CAAC;AAAA,QAC5D;AAEA,aAAK,UAAU;AAAA,UACb,MAAM;AAAA;AAAA,UACN,SAAS,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACpD,CAAC;AAED,aAAK,IAAI;AAET,cAAM;AAAA,MACR;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO;AACT;;;ACrHO,IAAM,SAAS;AAAA,EACpB,cAAc;AAAA,EACd,uBAAuB;AACzB;AAEO,IAAM,yBAAN,cAAqC,MAAM;AAAA,EAChD,YAAY,KAAe;AACzB;AAAA,MACE,0EAA0E,IAAI,MAAM;AAAA,IACtF;AAAA,EACF;AACF;AAKO,SAAS,eACd,KACA,MAC+B;AAC/B,SAAO,OAAO,UAAU,eAAe,KAAK,KAAK,IAAI;AACvD;AAEO,SAAS,KAA2B,KAAQ,MAAuB;AACxE,QAAM,MAAkB,CAAC;AACzB,OAAK,QAAQ,CAAC,QAAQ;AACpB,QAAI,GAAG,IAAI,IAAI,GAAG;AAAA,EACpB,CAAC;AACD,SAAO;AACT;AAEO,SAAS,YAAY,KAAqC;AAC/D,MAAI,OAAO,QAAQ,UAAU;AAC3B,UAAM,IAAI,MAAM,kDAAkD;AAAA,EACpE;AACF;AAEO,SAAS,aAAa,MAAyC;AACpE,MAAI,CAAC,MAAM,QAAQ,IAAI,KAAK,KAAK,KAAK,CAAC,QAAQ,OAAO,QAAQ,QAAQ,GAAG;AACvE,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACF;AAKO,IAAM,QAAQ;AAAA,EACnB,SAASA,OAAS,OAAa;AAE7B,QAAI,OAAO,oBAAoB;AAAY,aAAO,gBAAmB,KAAK;AAG1E,QAAI,UAAU;AAAW,aAAO;AAChC,WAAO,KAAK,MAAM,KAAK,UAAU,KAAK,CAAC;AAAA,EACzC;AAAA,EACA,EAAE,MAAM,QAAQ;AAClB;AAUA,SAAS,4BAA4B,MAAiC;AACpE,MAAI;AACF,UAAM,MAAM,IAAI,IAAI,IAAI;AACxB,QAAI,IAAI,SAAS;AAA0B,aAAO;AAClD,QAAI,IAAI,aAAa;AAAU,aAAO;AACtC,QAAI,CAAC,IAAI,SAAS,WAAW,OAAO;AAAG,aAAO;AAE9C,UAAM,KAAK,IAAI,SAAS,MAAM,GAAG,EAAE,CAAC;AACpC,QAAI,CAAC;AAAI,aAAO;AAEhB,UAAM,QAAQ,IAAI,aAAa,IAAI,OAAO;AAC1C,QAAI,CAAC,SAAS,UAAU;AAAI,aAAO;AAEnC,WAAO;AAAA,MACL,MAAM;AAAA,MACN,SAAS,kCAAkC,EAAE;AAAA,MAC7C;AAAA,MACA,SAAS;AAAA,MACT;AAAA,IACF;AAAA,EACF,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AA2BA,SAAS,8BACP,kBACmB;AACnB,MAAI;AACF,UAAM,MAAM,IAAI,IAAI,gBAAgB;AAEpC,QAAI,KAAoB,IAAI,aAAa,IAAI,IAAI;AACjD,UAAM,QAAQ,IAAI,aAAa,IAAI,OAAO;AAC1C,UAAMC,WAAU,IAAI,aAAa,IAAI,SAAS,KAAK;AAGnD,QAAI,CAAC,MAAM,IAAI,SAAS,WAAW,QAAQ,GAAG;AAC5C,WAAK,IAAI,SAAS,MAAM,GAAG,EAAE,CAAC,KAAK;AAAA,IACrC;AAEA,QAAI,CAAC,MAAM,CAAC;AAAO,aAAO;AAG1B,QAAI,SAAS;AAGb,WAAO;AAAA,MACL,MAAM;AAAA,MACN,SAAS,IAAI,SAAS;AAAA,MACtB;AAAA,MACA;AAAA,MACA,SAAAA;AAAA,IACF;AAAA,EACF,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAWO,SAAS,sBACd,kBACmB;AACnB,QAAM,aAAa,4BAA4B,gBAAgB;AAC/D,MAAI;AAAY,WAAO;AACvB,SAAO,8BAA8B,gBAAgB;AACvD;;;ACtJA,SAAS,eACP,qBAC4B;AAC5B,SAAO,IAAI,SAAS,oBAAoB,UAAU;AAAA,IAChD,SAAS;AAAA,MACP,GAAG,oBAAoB;AAAA,MACvB,KAAK;AAAA;AAAA,QAEH,KAAK,IAAI,GAAG,KAAK,OAAO,KAAK,IAAI,IAAI,oBAAoB,QAAQ,GAAI,CAAC;AAAA,MACxE;AAAA,IACF;AAAA,IACA,QAAQ,oBAAoB;AAAA,EAC9B,CAAC;AACH;AAKA,SAAS,yBACP,qBACA,cACA;AACA,SAAO,SAAS,mBACd,UAC4B;AAC5B,YAAQ,SAAS,QAAQ;AAAA,MACvB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,eAAO,OAAO,iBAAiB,YAC7B,oBAAoB,OAAO,KAAK,IAAI,IAAI,eAAe,MACrD,eAAe,mBAAmB,IAClC;AAAA,MACN;AACE,eAAO;AAAA,IACX;AAAA,EACF;AACF;AAKA,SAAS,kCACP,qBACA,cACA;AACA,SAAO,SAAS,mBACd,QAC4B;AAC5B,QACE,OAAO,iBAAiB,YACxB,oBAAoB,OAAO,KAAK,IAAI,IAAI,eAAe,KACvD;AACA,aAAO,eAAe,mBAAmB;AAAA,IAC3C;AACA,UAAM;AAAA,EACR;AACF;AAQO,IAAM,QAAQ,oBAAI,IAAiC;AAE1D,SAAS,oBAAoB,oBAAkD;AAC7E,MAAI,CAAC;AAAoB,WAAO;AAChC,QAAM,UAAU,uCAAuC;AAAA,IACrD;AAAA,EACF;AACA,UAAO,mCAAS,UAAS,OAAO,QAAQ,OAAO,YAAY,IAAI;AACjE;AAMO,IAAM,0BAA0B;AAAA,EACrC,eAAeC,yBACb,KACA,UAAwB,CAAC,GACY;AACrC,UAAM,EAAE,SAAS,gBAAgB,IAAI,QAAQ,GAAG,GAAG,cAAc,IAC/D;AACF,UAAM,aAAa,cAAc,IAAI,eAAe;AACpD,UAAM,WAAW,GAAG,GAAG,IAAI,cAAc,EAAE;AAE3C,UAAM,sBAAsB,MAAM,IAAI,QAAQ;AAE9C,QAAI,qBAAqB;AACvB,YAAM,EAAE,MAAAC,OAAM,UAAU,eAAe,IAAI;AAC3C,YAAM,UAAU,IAAI,QAAQ,aAAa;AACzC,cAAQ,IAAI,iBAAiBA,KAAI;AAEjC,YAAM,eAAe,oBAAoB,QAAQ,IAAI,eAAe,CAAC;AAErE,YAAMC,OAAkC,MAAM,MAAM,KAAK;AAAA,QACvD,GAAG;AAAA,QACH;AAAA,MACF,CAAC,EAAE;AAAA,QACD,yBAAyB,qBAAqB,YAAY;AAAA,QAC1D,kCAAkC,qBAAqB,YAAY;AAAA,MACrE;AAEA,UAAIA,KAAI,WAAW,KAAK;AACtB,QAAAA,KAAI,qBAAqB,KAAK,MAAM,cAAc;AAClD,eAAOA;AAAA,MACT;AAEA,YAAM,UAAUA,KAAI,QAAQ,IAAI,MAAM;AACtC,UAAIA,KAAI,MAAM;AACZ,cAAM,IAAI,UAAU;AAAA,UAClB,MAAM;AAAA,UACN,UAAU,MAAMA,KAAI,MAAM,EAAE,KAAK;AAAA,UACjC,SAAS,OAAO,YAAYA,KAAI,QAAQ,QAAQ,CAAC;AAAA,UACjD,QAAQA,KAAI;AAAA,UACZ,MAAM,KAAK,IAAI;AAAA,QACjB,CAAC;AACH,aAAOA;AAAA,IACT;AAEA,UAAM,MAAM,MAAM,MAAM,KAAK,OAAO;AACpC,UAAM,OAAO,IAAI,QAAQ,IAAI,MAAM;AACnC,QAAI,IAAI,MAAM,MAAM;AAClB,YAAM,IAAI,UAAU;AAAA,QAClB;AAAA,QACA,UAAU,MAAM,IAAI,MAAM,EAAE,KAAK;AAAA,QACjC,SAAS,OAAO,YAAY,IAAI,QAAQ,QAAQ,CAAC;AAAA,QACjD,QAAQ,IAAI;AAAA,QACZ,MAAM,KAAK,IAAI;AAAA,MACjB,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAAA,EACA;AAAA,IACE,MAAM;AAAA,IACN,kBAAkB,QAAQ;AACxB,aAAO;AAAA,QACL,QAAQ,OAAO;AAAA,MACjB;AAAA,IACF;AAAA,EACF;AACF;;;AJrIA,IAAM,iBAAiB,oBAAI,IAAqB;AAEhD,IAAM,iBAAiB,MAAM,UAAU,EAAE,MAAM,WAAW,CAAC;AAC3D,IAAM,kBAAkB,MAAM,KAAK,OAAO,EAAE,MAAM,aAAa,CAAC;AAEhE,IAAM,0BAA0B,OAAO,IAAI,mBAAmB;AAE9D,IAAM,wBAAwB;AAAA,EAC5B,CAAC,cAAsB,YAAoB;AACzC,UAAM,SAAS,eAAe,IAAI,YAAY;AAC9C,QAAI;AAAQ,aAAO;AAEnB,UAAM,SAAS,gBAAgB,OAAO;AAItC,mBAAe,IAAI,cAAc,OAAO,OAAO,MAAM,CAAC;AACtD,WAAO;AAAA,EACT;AAAA,EACA,EAAE,MAAM,oBAAoB;AAC9B;AAMA,IAAM,0BAA0B;AAAA,EAC9B,eAAeC,yBACb,YACoC;AAEpC,QAAI,WAAW,SAAS;AAAU,aAAO;AAEzC,QAAI,CAAC,QAAQ,IAAI;AAA0B,aAAO;AAElD,QAAI;AACF,YAAM,UAAU,MAAM;AAAA,QACpB,oBAAoB,WAAW,EAAE;AAAA,QACjC;AAAA,MACF;AAEA,aAAO;AAAA,QACL,WAAW;AAAA,QACX;AAAA,MACF;AAAA,IACF,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EACA;AAAA,IACE,MAAM;AAAA,EACR;AACF;AAMA,IAAM,uBAAuB;AAAA,EAC3B,eAAeC,sBACb,YACkD;AAClD,UAAM,oBAAoB,QAAQ;AAAA,MAChC;AAAA,MACA;AAAA,IACF;AAMA,QACE,OAAO,sBAAsB,YAC7B,OAAO,kBAAkB,QAAQ,YACjC;AACA,aAAO,kBAAkB,IAAI,WAAW,EAAE;AAAA,IAC5C;AAEA,WAAO;AAAA,EACT;AAAA,EACA;AAAA,IACE,MAAM;AAAA,EACR;AACF;AAOA,SAAS,4BACP,2BACA,YACA,SAC0C;AAE1C,MAAI,4BACF;AAMF,MAAI,gBAA2D;AAE/D,SAAO;AAAA,IACL,MAAM;AACJ,UAAI,CAAC;AAA2B,eAAO,QAAQ,QAAQ,IAAI;AAE3D,UAAI,CAAC,eAAe;AAClB,wBAAgB;AAAA,UACd,GAAG,WAAW,OAAO,kBAAkB,WAAW,OAAO;AAAA,UACzD;AAAA,YACE,SAAS,IAAI,QAAQ,OAAO;AAAA,YAC5B,OAAO;AAAA,UACT;AAAA,QACF,EAAE,KAAK,OAAO,QAAQ;AACpB,gBAAMC,UAAS,IAAI,QAAQ,IAAI,sBAAsB;AACrD,cAAI;AAGJ,cAAI,CAAC,IAAI,IAAI;AACX,kBAAM,oBAAoB,GAAG;AAC7B,mBAAO,IAAI;AACX,gBAAI,CAAC;AAAM,qBAAO;AAAA,UACpB,OAAO;AACL,mBAAQ,MAAM,IAAI,KAAK;AAAA,UACzB;AAEA,iBAAO,EAAE,QAAAA,SAAQ,OAAO,KAAK;AAAA,QAC/B,CAAC;AAID,sBAAc;AAAA,UACZ,CAAC,aAAa;AACZ,wCAA4B,QAAQ,QAAQ,QAAQ;AACpD,4BAAgB;AAAA,UAClB;AAAA;AAAA;AAAA;AAAA,UAIA,MAAM;AACJ,wCAA4B;AAC5B,4BAAgB;AAAA,UAClB;AAAA,QACF;AAAA,MACF;AAEA,UAAI,CAAC,2BAA2B;AAI9B,oCAA4B;AAAA,MAC9B;AAEA,aAAO;AAAA,IACT;AAAA,IACA;AAAA,MACE,MAAM;AAAA,IACR;AAAA,EACF;AACF;AAKA,eAAe,mBACb,YACkD;AAClD,QAAM,aACH,MAAM,qBAAqB,UAAU,KACrC,MAAM,wBAAwB,UAAU;AAE3C,SAAO;AACT;AAoBA,eAAe,oBAAoB,KAA8B;AAC/D,QAAM,IAAI,YAAY;AACxB;AAqCO,IAAM,eAAe;AAAA,EAC1B,SAASC,cACP,kBACA,UAAmC;AAAA,IAAE,cAAc;AAAA;AAAA,EAAsB,GACvD;AAClB,QAAI,CAAC;AACH,YAAM,IAAI,MAAM,oDAAoD;AAEtE,UAAM,aAAa,sBAAsB,gBAAgB;AAEzD,QAAI,CAAC;AACH,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAEF,UAAM,eAAe,WAAW;AAChC,UAAM,UAAU,WAAW;AAC3B,UAAMP,WAAU,WAAW;AAC3B,UAAM,UAAkC;AAAA,MACtC,eAAe,UAAU,WAAW,KAAK;AAAA,IAC3C;AAGA,QAAI,OAAO,YAAY,eAAe,QAAQ,IAAI;AAChD,cAAQ,0BAA0B,IAAI,QAAQ,IAAI;AAEpD,QAAI,OAAO,SAAY,YAAY,OAAO,YAAe;AACvD,cAAQ,mBAAmB,IAAI,GAAG,IAAO,IAAI,OAAU;AAEzD,QAAI,OAAO,QAAQ,iBAAiB,YAAY,QAAQ,eAAe;AACrE,cAAQ,eAAe,IAAI,kBAAkB,QAAQ,YAAY;AAMnE,UAAM,4BACJ,CAAC,QAAQ,2BACT,QAAQ,IAAI,aAAa,iBACzB,QAAQ,IAAI,wCAAwC;AAEtD,UAAM,wBAAwB;AAAA,MAC5B;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,UAAM,MAA4C;AAAA,MAChD,KAAK;AAAA,QACH,eAAeQ,KACb,KACsC;AACtC,gBAAM,kBACH,MAAM,sBAAsB,KAC5B,MAAM,mBAAmB,UAAU;AAEtC,cAAI,iBAAiB;AACnB,wBAAY,GAAG;AAMf,mBAAO,QAAQ;AAAA,cACb,gBAAgB,MAAM,GAAG;AAAA,YAC3B;AAAA,UACF;AAEA,sBAAY,GAAG;AACf,iBAAO;AAAA,YACL,GAAG,OAAO,SAAS,GAAG,YAAYR,QAAO;AAAA,YACzC;AAAA,cACE,SAAS,IAAI,QAAQ,OAAO;AAAA,cAC5B,OAAO;AAAA,YACT;AAAA,UACF,EAAE,KAA6C,OAAO,QAAQ;AAC5D,gBAAI,IAAI;AAAI,qBAAO,IAAI,KAAK;AAC5B,kBAAM,oBAAoB,GAAG;AAE7B,gBAAI,IAAI,WAAW;AAAK,oBAAM,IAAI,MAAM,OAAO,YAAY;AAC3D,gBAAI,IAAI,WAAW,KAAK;AAGtB,kBAAI,IAAI,QAAQ,IAAI,sBAAsB;AAAG,uBAAO;AAGpD,oBAAM,IAAI,MAAM,OAAO,qBAAqB;AAAA,YAC9C;AACA,gBAAI,IAAI,uBAAuB;AAC7B,qBAAO,IAAI;AACb,kBAAM,IAAI,uBAAuB,GAAG;AAAA,UACtC,CAAC;AAAA,QACH;AAAA,QACA,EAAE,MAAM,OAAO,gBAAgB,OAAO,YAAY,EAAE,aAAa,EAAE;AAAA,MACrE;AAAA,MACA,KAAK;AAAA,QACH,eAAeS,KAAI,KAAuB;AACxC,gBAAM,kBACH,MAAM,sBAAsB,KAC5B,MAAM,mBAAmB,UAAU;AAEtC,cAAI,iBAAiB;AACnB,wBAAY,GAAG;AACf,mBAAO,QAAQ,QAAQ,eAAe,gBAAgB,OAAO,GAAG,CAAC;AAAA,UACnE;AAEA,sBAAY,GAAG;AAEf,iBAAO,MAAM,GAAG,OAAO,SAAS,GAAG,YAAYT,QAAO,IAAI;AAAA,YACxD,QAAQ;AAAA,YACR,SAAS,IAAI,QAAQ,OAAO;AAAA,YAC5B,OAAO;AAAA,UACT,CAAC,EAAE,KAAK,CAAC,QAAQ;AACf,gBAAI,IAAI,WAAW;AAAK,oBAAM,IAAI,MAAM,OAAO,YAAY;AAC3D,gBAAI,IAAI,WAAW,KAAK;AAGtB,kBAAI,IAAI,QAAQ,IAAI,sBAAsB;AAAG,uBAAO;AAGpD,oBAAM,IAAI,MAAM,OAAO,qBAAqB;AAAA,YAC9C;AACA,gBAAI,IAAI;AAAI,qBAAO;AACnB,kBAAM,IAAI,uBAAuB,GAAG;AAAA,UACtC,CAAC;AAAA,QACH;AAAA,QACA,EAAE,MAAM,OAAO,gBAAgB,OAAO,YAAY,EAAE,aAAa,EAAE;AAAA,MACrE;AAAA,MACA,QAAQ;AAAA,QACN,eAAeU,QACb,MAC0B;AAC1B,gBAAM,kBACH,MAAM,sBAAsB,KAC5B,MAAM,mBAAmB,UAAU;AAEtC,cAAI,iBAAiB;AACnB,gBAAI,SAAS,QAAW;AACtB,qBAAO,QAAQ,QAAQ,gBAAgB,KAAwB;AAAA,YACjE;AAEA,yBAAa,IAAI;AACjB,mBAAO,QAAQ;AAAA,cACb,KAAK,gBAAgB,OAAO,IAAI;AAAA,YAClC;AAAA,UACF;AAEA,cAAI,MAAM,QAAQ,IAAI;AAAG,yBAAa,IAAI;AAE1C,gBAAM,SAAS,MAAM,QAAQ,IAAI,IAC7B,IAAI;AAAA,YACF,KAAK,IAAI,CAAC,QAAQ,CAAC,OAAO,GAAG,CAAqB;AAAA,UACpD,EAAE,SAAS,IACX;AAIJ,cAAI,WAAW;AAAI,mBAAO,QAAQ,QAAQ,CAAC,CAAoB;AAE/D,iBAAO;AAAA,YACL,GAAG,OAAO,kBAAkBV,QAAO,GACjC,WAAW,OAAO,KAAK,IAAI,MAAM,EACnC;AAAA,YACA;AAAA,cACE,SAAS,IAAI,QAAQ,OAAO;AAAA,cAC5B,OAAO;AAAA,YACT;AAAA,UACF,EAAE,KAAsB,OAAO,QAAQ;AACrC,gBAAI,IAAI;AAAI,qBAAO,IAAI,KAAK;AAC5B,kBAAM,oBAAoB,GAAG;AAE7B,gBAAI,IAAI,WAAW;AAAK,oBAAM,IAAI,MAAM,OAAO,YAAY;AAG3D,gBAAI,IAAI,WAAW;AACjB,oBAAM,IAAI,MAAM,OAAO,qBAAqB;AAC9C,gBAAI,IAAI,uBAAuB;AAC7B,qBAAO,IAAI;AACb,kBAAM,IAAI,uBAAuB,GAAG;AAAA,UACtC,CAAC;AAAA,QACH;AAAA,QACA,EAAE,MAAM,UAAU,gBAAgB,OAAO,YAAY,EAAE,aAAa,EAAE;AAAA,MACxE;AAAA,MACA,QAAQ;AAAA,QACN,eAAeM,UAA0B;AACvC,gBAAM,kBACH,MAAM,sBAAsB,KAC5B,MAAM,mBAAmB,UAAU;AAEtC,cAAI,iBAAiB;AACnB,mBAAO,QAAQ,QAAQ,gBAAgB,MAAM;AAAA,UAC/C;AAEA,iBAAO;AAAA,YACL,GAAG,OAAO,mBAAmBN,QAAO;AAAA,YACpC;AAAA,cACE,SAAS,IAAI,QAAQ,OAAO;AAAA,cAC5B,OAAO;AAAA,YACT;AAAA,UACF,EAAE,KAAK,OAAO,QAAQ;AACpB,gBAAI,IAAI;AAAI,qBAAO,IAAI,KAAK;AAC5B,kBAAM,oBAAoB,GAAG;AAE7B,gBAAI,IAAI,uBAAuB;AAC7B,qBAAO,IAAI;AACb,kBAAM,IAAI,uBAAuB,GAAG;AAAA,UACtC,CAAC;AAAA,QACH;AAAA,QACA,EAAE,MAAM,UAAU,gBAAgB,OAAO,YAAY,EAAE,aAAa,EAAE;AAAA,MACxE;AAAA,IACF;AAEA,WAAO,EAAE,GAAG,KAAK,WAAW;AAAA,EAC9B;AAAA,EACA;AAAA,IACE,MAAM;AAAA,EACR;AACF;AAEA,IAAI;AAIJ,SAAS,OAAa;AAEpB,MAAI,CAAC,yBAAyB;AAC5B,8BAA0B,aAAa,QAAQ,IAAI,WAAW;AAAA,EAChE;AACF;AAYO,IAAM,MAA+B,IAAI,SAAS;AACvD,OAAK;AACL,SAAO,wBAAwB,IAAI,GAAG,IAAI;AAC5C;AAYO,IAAM,SAAqC,IAAI,SAAS;AAC7D,OAAK;AACL,SAAO,wBAAwB,OAAO,GAAG,IAAI;AAC/C;AAYO,IAAM,MAA+B,IAAI,SAAS;AACvD,OAAK;AACL,SAAO,wBAAwB,IAAI,GAAG,IAAI;AAC5C;AAWO,IAAM,SAAqC,IAAI,SAAS;AAC7D,OAAK;AACL,SAAO,wBAAwB,OAAO,GAAG,IAAI;AAC/C;AAKO,SAASD,OACd,iBACiB;AAGjB,SAAO,KAAK,MAAM,KAAK,UAAU,eAAe,CAAC;AACnD","sourcesContent":["import { readFile } from '@vercel/edge-config-fs';\nimport type { DeepReadonly, DeepWritable } from 'ts-essentials';\nimport { name as sdkName, version as sdkVersion } from '../package.json';\nimport {\n  assertIsKey,\n  assertIsKeys,\n  ERRORS,\n  UnexpectedNetworkError,\n  hasOwnProperty,\n  parseConnectionString,\n  pick,\n} from './utils';\nimport type {\n  Connection,\n  EdgeConfigClient,\n  EdgeConfigItems,\n  EdgeConfigValue,\n  EmbeddedEdgeConfig,\n} from './types';\nimport { fetchWithCachedResponse } from './utils/fetch-with-cached-response';\nimport { trace } from './utils/tracing';\n\nexport { setTracerProvider } from './utils/tracing';\n\nexport {\n  parseConnectionString,\n  type EdgeConfigClient,\n  type EdgeConfigItems,\n  type EdgeConfigValue,\n  type EmbeddedEdgeConfig,\n};\n\nconst jsonParseCache = new Map<string, unknown>();\n\nconst readFileTraced = trace(readFile, { name: 'readFile' });\nconst jsonParseTraced = trace(JSON.parse, { name: 'JSON.parse' });\n\nconst privateEdgeConfigSymbol = Symbol.for('privateEdgeConfig');\n\nconst cachedJsonParseTraced = trace(\n  (edgeConfigId: string, content: string) => {\n    const cached = jsonParseCache.get(edgeConfigId);\n    if (cached) return cached;\n\n    const parsed = jsonParseTraced(content) as unknown;\n\n    // freeze the object to avoid mutations of the return value of a \"get\" call\n    // from affecting the return value of future \"get\" calls\n    jsonParseCache.set(edgeConfigId, Object.freeze(parsed));\n    return parsed;\n  },\n  { name: 'cached JSON.parse' },\n);\n\n/**\n * Reads an Edge Config from the local file system.\n * This is used at runtime on serverless functions.\n */\nconst getFileSystemEdgeConfig = trace(\n  async function getFileSystemEdgeConfig(\n    connection: Connection,\n  ): Promise<EmbeddedEdgeConfig | null> {\n    // can't optimize non-vercel hosted edge configs\n    if (connection.type !== 'vercel') return null;\n    // can't use fs optimizations outside of lambda\n    if (!process.env.AWS_LAMBDA_FUNCTION_NAME) return null;\n\n    try {\n      const content = await readFileTraced(\n        `/opt/edge-config/${connection.id}.json`,\n        'utf-8',\n      );\n\n      return cachedJsonParseTraced(\n        connection.id,\n        content,\n      ) as EmbeddedEdgeConfig;\n    } catch {\n      return null;\n    }\n  },\n  {\n    name: 'getFileSystemEdgeConfig',\n  },\n);\n\n/**\n * Will return an embedded Edge Config object from memory,\n * but only when the `privateEdgeConfigSymbol` is in global scope.\n */\nconst getPrivateEdgeConfig = trace(\n  async function getPrivateEdgeConfig(\n    connection: Connection,\n  ): Promise<DeepReadonly<EmbeddedEdgeConfig> | null> {\n    const privateEdgeConfig = Reflect.get(\n      globalThis,\n      privateEdgeConfigSymbol,\n    ) as\n      | {\n          get: (id: string) => Promise<DeepReadonly<EmbeddedEdgeConfig> | null>;\n        }\n      | undefined;\n\n    if (\n      typeof privateEdgeConfig === 'object' &&\n      typeof privateEdgeConfig.get === 'function'\n    ) {\n      return privateEdgeConfig.get(connection.id);\n    }\n\n    return null;\n  },\n  {\n    name: 'getPrivateEdgeConfig',\n  },\n);\n\n/**\n * Returns a function to retrieve the entire Edge Config.\n * It'll keep the fetched Edge Config in memory, making subsequent calls fast,\n * while revalidating in the background.\n */\nfunction createGetInMemoryEdgeConfig(\n  shouldUseDevelopmentCache: boolean,\n  connection: Connection,\n  headers: Record<string, string>,\n): () => Promise<EmbeddedEdgeConfig | null> {\n  // Functions as cache to keep track of the Edge Config.\n  let embeddedEdgeConfigPromise: Promise<EmbeddedEdgeConfig | null> | null =\n    null;\n\n  // Promise that points to the most recent request.\n  // It'll ensure that subsequent calls won't make another fetch call,\n  // while one is still on-going.\n  // Will overwrite `embeddedEdgeConfigPromise` only when resolved.\n  let latestRequest: Promise<EmbeddedEdgeConfig | null> | null = null;\n\n  return trace(\n    () => {\n      if (!shouldUseDevelopmentCache) return Promise.resolve(null);\n\n      if (!latestRequest) {\n        latestRequest = fetchWithCachedResponse(\n          `${connection.baseUrl}/items?version=${connection.version}`,\n          {\n            headers: new Headers(headers),\n            cache: 'no-store',\n          },\n        ).then(async (res) => {\n          const digest = res.headers.get('x-edge-config-digest');\n          let body: EdgeConfigValue | undefined;\n\n          // We ignore all errors here and just proceed.\n          if (!res.ok) {\n            await consumeResponseBody(res);\n            body = res.cachedResponseBody as EdgeConfigValue | undefined;\n            if (!body) return null;\n          } else {\n            body = (await res.json()) as EdgeConfigItems;\n          }\n\n          return { digest, items: body } as EmbeddedEdgeConfig;\n        });\n\n        // Once the request is resolved, we set the proper config to the promise\n        // such that the next call will return the resolved value.\n        latestRequest.then(\n          (resolved) => {\n            embeddedEdgeConfigPromise = Promise.resolve(resolved);\n            latestRequest = null;\n          },\n          // Attach a `.catch` handler to this promise so that if it does throw,\n          // we don't get an unhandled promise rejection event. We unset the\n          // `latestRequest` so that the next call will make a new request.\n          () => {\n            embeddedEdgeConfigPromise = null;\n            latestRequest = null;\n          },\n        );\n      }\n\n      if (!embeddedEdgeConfigPromise) {\n        // If the `embeddedEdgeConfigPromise` is `null`, it means that there's\n        // no previous request, so we'll set the `latestRequest` to the current\n        // request.\n        embeddedEdgeConfigPromise = latestRequest;\n      }\n\n      return embeddedEdgeConfigPromise;\n    },\n    {\n      name: 'getInMemoryEdgeConfig',\n    },\n  );\n}\n\n/**\n *\n */\nasync function getLocalEdgeConfig(\n  connection: Connection,\n): Promise<DeepReadonly<EmbeddedEdgeConfig> | null> {\n  const edgeConfig =\n    (await getPrivateEdgeConfig(connection)) ||\n    (await getFileSystemEdgeConfig(connection));\n\n  return edgeConfig;\n}\n\n/**\n * This function reads the respone body\n *\n * Reading the response body serves two purposes\n *\n * 1) In Node.js it avoids memory leaks\n *\n * See https://github.com/nodejs/undici/blob/v5.21.2/README.md#garbage-collection\n * See https://github.com/node-fetch/node-fetch/issues/83\n *\n * 2) In Cloudflare it avoids running into a deadlock. They have a maximum number\n * of concurrent fetches (which is documented). Concurrency counts until the\n * body of a response is read. It is not uncommon to never read a response body\n * (e.g. if you only care about the status code). This can lead to deadlock as\n * fetches appear to never resolve.\n *\n * See https://developers.cloudflare.com/workers/platform/limits/#simultaneous-open-connections\n */\nasync function consumeResponseBody(res: Response): Promise<void> {\n  await res.arrayBuffer();\n}\n\ninterface EdgeConfigClientOptions {\n  /**\n   * The stale-if-error response directive indicates that the cache can reuse a\n   * stale response when an upstream server generates an error, or when the error\n   * is generated locally - for example due to a connection error.\n   *\n   * Any response with a status code of 500, 502, 503, or 504 is considered an error.\n   *\n   * Pass a negative number, 0, or false to turn disable stale-if-error semantics.\n   *\n   * The time is supplied in seconds. Defaults to one week (`604800`).\n   */\n  staleIfError?: number | false;\n  /**\n   * In development, a stale-while-revalidate cache is employed as the default caching strategy.\n   *\n   * This cache aims to deliver speedy Edge Config reads during development, though it comes\n   * at the cost of delayed visibility for updates to Edge Config. Typically, you may need to\n   * refresh twice to observe these changes as the stale value is replaced.\n   *\n   * This cache is not used in preview or production deployments as superior optimisations are applied there.\n   */\n  disableDevelopmentCache?: boolean;\n}\n\n/**\n * Create an Edge Config client.\n *\n * The client has multiple methods which allow you to read the Edge Config.\n *\n * If you need to programmatically write to an Edge Config, check out the [Update your Edge Config items](https://vercel.com/docs/storage/edge-config/vercel-api#update-your-edge-config-items) section.\n *\n * @param connectionString - A connection string. Usually you'd pass in `process.env.EDGE_CONFIG` here, which contains a connection string.\n * @returns An Edge Config Client instance\n */\nexport const createClient = trace(\n  function createClient(\n    connectionString: string | undefined,\n    options: EdgeConfigClientOptions = { staleIfError: 604800 /* one week */ },\n  ): EdgeConfigClient {\n    if (!connectionString)\n      throw new Error('@vercel/edge-config: No connection string provided');\n\n    const connection = parseConnectionString(connectionString);\n\n    if (!connection)\n      throw new Error(\n        '@vercel/edge-config: Invalid connection string provided',\n      );\n\n    const edgeConfigId = connection.id;\n    const baseUrl = connection.baseUrl;\n    const version = connection.version; // version of the edge config read access api we talk to\n    const headers: Record<string, string> = {\n      Authorization: `Bearer ${connection.token}`,\n    };\n\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain -- [@vercel/style-guide@5 migration]\n    if (typeof process !== 'undefined' && process.env.VERCEL_ENV)\n      headers['x-edge-config-vercel-env'] = process.env.VERCEL_ENV;\n\n    if (typeof sdkName === 'string' && typeof sdkVersion === 'string')\n      headers['x-edge-config-sdk'] = `${sdkName}@${sdkVersion}`;\n\n    if (typeof options.staleIfError === 'number' && options.staleIfError > 0)\n      headers['cache-control'] = `stale-if-error=${options.staleIfError}`;\n\n    /**\n     * While in development we use SWR-like behavior for the api client to\n     * reduce latency.\n     */\n    const shouldUseDevelopmentCache =\n      !options.disableDevelopmentCache &&\n      process.env.NODE_ENV === 'development' &&\n      process.env.EDGE_CONFIG_DISABLE_DEVELOPMENT_SWR !== '1';\n\n    const getInMemoryEdgeConfig = createGetInMemoryEdgeConfig(\n      shouldUseDevelopmentCache,\n      connection,\n      headers,\n    );\n\n    const api: Omit<EdgeConfigClient, 'connection'> = {\n      get: trace(\n        async function get<T = EdgeConfigValue>(\n          key: string,\n        ): Promise<DeepReadonly<T> | undefined> {\n          const localEdgeConfig =\n            (await getInMemoryEdgeConfig()) ||\n            (await getLocalEdgeConfig(connection));\n\n          if (localEdgeConfig) {\n            assertIsKey(key);\n\n            // We need to return a clone of the value so users can't modify\n            // our original value, and so the reference changes.\n            //\n            // This makes it consistent with the real API.\n            return Promise.resolve(\n              localEdgeConfig.items[key] as DeepReadonly<T>,\n            );\n          }\n\n          assertIsKey(key);\n          return fetchWithCachedResponse(\n            `${baseUrl}/item/${key}?version=${version}`,\n            {\n              headers: new Headers(headers),\n              cache: 'no-store',\n            },\n          ).then<DeepReadonly<T> | undefined, undefined>(async (res) => {\n            if (res.ok) return res.json();\n            await consumeResponseBody(res);\n\n            if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n            if (res.status === 404) {\n              // if the x-edge-config-digest header is present, it means\n              // the edge config exists, but the item does not\n              if (res.headers.has('x-edge-config-digest')) return undefined;\n              // if the x-edge-config-digest header is not present, it means\n              // the edge config itself does not exist\n              throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n            }\n            if (res.cachedResponseBody !== undefined)\n              return res.cachedResponseBody as DeepReadonly<T>;\n            throw new UnexpectedNetworkError(res);\n          });\n        },\n        { name: 'get', isVerboseTrace: false, attributes: { edgeConfigId } },\n      ),\n      has: trace(\n        async function has(key): Promise<boolean> {\n          const localEdgeConfig =\n            (await getInMemoryEdgeConfig()) ||\n            (await getLocalEdgeConfig(connection));\n\n          if (localEdgeConfig) {\n            assertIsKey(key);\n            return Promise.resolve(hasOwnProperty(localEdgeConfig.items, key));\n          }\n\n          assertIsKey(key);\n          // this is a HEAD request anyhow, no need for fetchWithCachedResponse\n          return fetch(`${baseUrl}/item/${key}?version=${version}`, {\n            method: 'HEAD',\n            headers: new Headers(headers),\n            cache: 'no-store',\n          }).then((res) => {\n            if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n            if (res.status === 404) {\n              // if the x-edge-config-digest header is present, it means\n              // the edge config exists, but the item does not\n              if (res.headers.has('x-edge-config-digest')) return false;\n              // if the x-edge-config-digest header is not present, it means\n              // the edge config itself does not exist\n              throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n            }\n            if (res.ok) return true;\n            throw new UnexpectedNetworkError(res);\n          });\n        },\n        { name: 'has', isVerboseTrace: false, attributes: { edgeConfigId } },\n      ),\n      getAll: trace(\n        async function getAll<T = EdgeConfigItems>(\n          keys?: (keyof T)[],\n        ): Promise<DeepReadonly<T>> {\n          const localEdgeConfig =\n            (await getInMemoryEdgeConfig()) ||\n            (await getLocalEdgeConfig(connection));\n\n          if (localEdgeConfig) {\n            if (keys === undefined) {\n              return Promise.resolve(localEdgeConfig.items as DeepReadonly<T>);\n            }\n\n            assertIsKeys(keys);\n            return Promise.resolve(\n              pick(localEdgeConfig.items, keys) as DeepReadonly<T>,\n            );\n          }\n\n          if (Array.isArray(keys)) assertIsKeys(keys);\n\n          const search = Array.isArray(keys)\n            ? new URLSearchParams(\n                keys.map((key) => ['key', key] as [string, string]),\n              ).toString()\n            : null;\n\n          // empty search keys array was given,\n          // so skip the request and return an empty object\n          if (search === '') return Promise.resolve({} as DeepReadonly<T>);\n\n          return fetchWithCachedResponse(\n            `${baseUrl}/items?version=${version}${\n              search === null ? '' : `&${search}`\n            }`,\n            {\n              headers: new Headers(headers),\n              cache: 'no-store',\n            },\n          ).then<DeepReadonly<T>>(async (res) => {\n            if (res.ok) return res.json();\n            await consumeResponseBody(res);\n\n            if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n            // the /items endpoint never returns 404, so if we get a 404\n            // it means the edge config itself did not exist\n            if (res.status === 404)\n              throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n            if (res.cachedResponseBody !== undefined)\n              return res.cachedResponseBody as T;\n            throw new UnexpectedNetworkError(res);\n          });\n        },\n        { name: 'getAll', isVerboseTrace: false, attributes: { edgeConfigId } },\n      ),\n      digest: trace(\n        async function digest(): Promise<string> {\n          const localEdgeConfig =\n            (await getInMemoryEdgeConfig()) ||\n            (await getLocalEdgeConfig(connection));\n\n          if (localEdgeConfig) {\n            return Promise.resolve(localEdgeConfig.digest);\n          }\n\n          return fetchWithCachedResponse(\n            `${baseUrl}/digest?version=${version}`,\n            {\n              headers: new Headers(headers),\n              cache: 'no-store',\n            },\n          ).then(async (res) => {\n            if (res.ok) return res.json() as Promise<string>;\n            await consumeResponseBody(res);\n\n            if (res.cachedResponseBody !== undefined)\n              return res.cachedResponseBody as string;\n            throw new UnexpectedNetworkError(res);\n          });\n        },\n        { name: 'digest', isVerboseTrace: false, attributes: { edgeConfigId } },\n      ),\n    };\n\n    return { ...api, connection };\n  },\n  {\n    name: 'createClient',\n  },\n);\n\nlet defaultEdgeConfigClient: EdgeConfigClient;\n\n// lazy init fn so the default edge config does not throw in case\n// process.env.EDGE_CONFIG is not defined and its methods are never used.\nfunction init(): void {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- [@vercel/style-guide@5 migration]\n  if (!defaultEdgeConfigClient) {\n    defaultEdgeConfigClient = createClient(process.env.EDGE_CONFIG);\n  }\n}\n\n/**\n * Reads a single item from the default Edge Config.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).get()`.\n *\n * @see {@link EdgeConfigClient.get}\n * @param key - the key to read\n * @returns the value stored under the given key, or undefined\n */\nexport const get: EdgeConfigClient['get'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.get(...args);\n};\n\n/**\n * Reads multiple or all values.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).getAll()`.\n *\n * @see {@link EdgeConfigClient.getAll}\n * @param keys - the keys to read\n * @returns the value stored under the given key, or undefined\n */\nexport const getAll: EdgeConfigClient['getAll'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.getAll(...args);\n};\n\n/**\n * Check if a given key exists in the Edge Config.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).has()`.\n *\n * @see {@link EdgeConfigClient.has}\n * @param key - the key to check\n * @returns true if the given key exists in the Edge Config.\n */\nexport const has: EdgeConfigClient['has'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.has(...args);\n};\n\n/**\n * Get the digest of the Edge Config.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).digest()`.\n *\n * @see {@link EdgeConfigClient.digest}\n * @returns The digest of the Edge Config.\n */\nexport const digest: EdgeConfigClient['digest'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.digest(...args);\n};\n\n/**\n * Safely clones a read-only Edge Config object and makes it mutable.\n */\nexport function clone<T = EdgeConfigValue>(\n  edgeConfigValue: T,\n): DeepWritable<T> {\n  // Use JSON.parse and JSON.stringify instead of anything else due to\n  // the value possibly being a Proxy object.\n  return JSON.parse(JSON.stringify(edgeConfigValue)) as DeepWritable<T>;\n}\n","{\n  \"name\": \"@vercel/edge-config\",\n  \"version\": \"1.1.1\",\n  \"description\": \"Ultra-low latency data at the edge\",\n  \"homepage\": \"https://vercel.com\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/vercel/storage.git\",\n    \"directory\": \"packages/edge-config\"\n  },\n  \"license\": \"Apache-2.0\",\n  \"sideEffects\": false,\n  \"type\": \"module\",\n  \"exports\": {\n    \"import\": \"./dist/index.js\",\n    \"require\": \"./dist/index.cjs\"\n  },\n  \"main\": \"./dist/index.cjs\",\n  \"module\": \"./dist/index.js\",\n  \"files\": [\n    \"dist\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"dev\": \"tsup --watch --clean=false\",\n    \"lint\": \"eslint --max-warnings=0 .\",\n    \"prepublishOnly\": \"pnpm run build\",\n    \"prettier-check\": \"prettier --check .\",\n    \"publint\": \"npx publint\",\n    \"test\": \"pnpm run test:node && pnpm run test:edge && pnpm run test:common\",\n    \"test:common\": \"jest --env @edge-runtime/jest-environment .common.test.ts && jest --env node .common.test.ts\",\n    \"test:edge\": \"jest --env @edge-runtime/jest-environment .edge.test.ts\",\n    \"test:node\": \"jest --env node .node.test.ts\",\n    \"type-check\": \"tsc --noEmit\"\n  },\n  \"jest\": {\n    \"preset\": \"ts-jest\",\n    \"setupFiles\": [\n      \"<rootDir>/jest/setup.js\"\n    ],\n    \"testEnvironment\": \"node\"\n  },\n  \"dependencies\": {\n    \"@vercel/edge-config-fs\": \"workspace:*\",\n    \"ts-essentials\": \"9.4.1\"\n  },\n  \"devDependencies\": {\n    \"@changesets/cli\": \"2.27.1\",\n    \"@edge-runtime/jest-environment\": \"2.3.10\",\n    \"@edge-runtime/types\": \"2.2.9\",\n    \"@types/jest\": \"29.5.12\",\n    \"@types/node\": \"20.11.19\",\n    \"eslint\": \"8.56.0\",\n    \"eslint-config-custom\": \"workspace:*\",\n    \"jest\": \"29.7.0\",\n    \"jest-fetch-mock\": \"3.0.3\",\n    \"node-domexception\": \"2.0.1\",\n    \"prettier\": \"3.2.5\",\n    \"ts-jest\": \"29.1.2\",\n    \"tsconfig\": \"workspace:*\",\n    \"tsup\": \"8.0.2\",\n    \"typescript\": \"5.3.3\"\n  },\n  \"peerDependencies\": {\n    \"@opentelemetry/api\": \"^1.7.0\"\n  },\n  \"peerDependenciesMeta\": {\n    \"@opentelemetry/api\": {\n      \"optional\": true\n    }\n  },\n  \"engines\": {\n    \"node\": \">=14.6\"\n  }\n}\n","import type { Tracer, Attributes, TracerProvider } from '@opentelemetry/api';\nimport { name as pkgName, version } from '../../package.json';\n\n// Use a symbol to avoid having global variable that is scoped to this file,\n// as it can lead to issues with cjs and mjs being used at the same time.\nconst edgeConfigTraceSymbol = Symbol.for('@vercel/edge-config:global-trace');\n\n/**\n * Allows setting the `@opentelemetry/api` tracer provider to generate traces\n * for Edge Config related operations.\n */\nexport function setTracerProvider(tracer: TracerProvider): void {\n  Reflect.set(globalThis, edgeConfigTraceSymbol, tracer);\n}\n\nfunction getTracer(): Tracer | undefined {\n  const maybeTraceApi = Reflect.get(globalThis, edgeConfigTraceSymbol) as\n    | undefined\n    | TracerProvider;\n  return maybeTraceApi?.getTracer(pkgName, version);\n}\n\nfunction isPromise<T>(p: unknown): p is Promise<T> {\n  return (\n    p !== null &&\n    typeof p === 'object' &&\n    'then' in p &&\n    typeof p.then === 'function'\n  );\n}\n\n/* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any -- bc */\nexport function trace<F extends (...args: any) => any>(\n  fn: F,\n  options: {\n    name: string;\n    /** Defaults to `true`. If set to `false`, it'll trace regardless of `EDGE_CONFIG_TRACE_VERBOSE`. */\n    isVerboseTrace?: boolean;\n    attributes?: Attributes;\n    attributesSuccess?: (\n      result: ReturnType<F> extends PromiseLike<infer U> ? U : ReturnType<F>,\n    ) => Attributes;\n    attributesError?: (error: Error) => Attributes;\n  } = {\n    name: fn.name,\n  },\n): F {\n  const traced = function (this: unknown, ...args: unknown[]): unknown {\n    const tracer = getTracer();\n    if (!tracer) return fn.apply(this, args);\n\n    const shouldTrace =\n      process.env.EDGE_CONFIG_TRACE_VERBOSE === 'true' ||\n      options.isVerboseTrace === false;\n    if (!shouldTrace) return fn.apply(this, args);\n\n    return tracer.startActiveSpan(options.name, (span) => {\n      if (options.attributes) span.setAttributes(options.attributes);\n\n      try {\n        const result = fn.apply(this, args);\n\n        if (isPromise(result)) {\n          result\n            .then((value) => {\n              if (options.attributesSuccess) {\n                span.setAttributes(\n                  options.attributesSuccess(\n                    value as ReturnType<F> extends PromiseLike<infer U>\n                      ? U\n                      : ReturnType<F>,\n                  ),\n                );\n              }\n\n              span.setStatus({ code: 1 }); // 1 = Ok\n              span.end();\n            })\n            .catch((error) => {\n              if (options.attributesError) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- k\n                span.setAttributes(options.attributesError(error));\n              }\n\n              span.setStatus({\n                code: 2, // 2 = Error\n                message: error instanceof Error ? error.message : undefined,\n              });\n\n              span.end();\n            });\n        } else {\n          if (options.attributesSuccess) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- k\n            span.setAttributes(options.attributesSuccess(result));\n          }\n\n          span.setStatus({ code: 1 }); // 1 = Ok\n          span.end();\n        }\n\n        return result as unknown;\n      } catch (error: any) {\n        if (options.attributesError) {\n          span.setAttributes(options.attributesError(error as Error));\n        }\n\n        span.setStatus({\n          code: 2, // 2 = Error\n          message: error instanceof Error ? error.message : undefined,\n        });\n\n        span.end();\n\n        throw error;\n      }\n    });\n  };\n\n  return traced as unknown as F;\n}\n/* eslint-enable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any -- k */\n","import type { Connection } from '../types';\nimport { trace } from './tracing';\n\nexport const ERRORS = {\n  UNAUTHORIZED: '@vercel/edge-config: Unauthorized',\n  EDGE_CONFIG_NOT_FOUND: '@vercel/edge-config: Edge Config not found',\n};\n\nexport class UnexpectedNetworkError extends Error {\n  constructor(res: Response) {\n    super(\n      `@vercel/edge-config: Unexpected error due to response with status code ${res.status}`,\n    );\n  }\n}\n\n/**\n * Checks if an object has a property\n */\nexport function hasOwnProperty<X, Y extends PropertyKey>(\n  obj: X,\n  prop: Y,\n): obj is X & Record<Y, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nexport function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const ret: Partial<T> = {};\n  keys.forEach((key) => {\n    ret[key] = obj[key];\n  });\n  return ret as Pick<T, K>;\n}\n\nexport function assertIsKey(key: unknown): asserts key is string {\n  if (typeof key !== 'string') {\n    throw new Error('@vercel/edge-config: Expected key to be a string');\n  }\n}\n\nexport function assertIsKeys(keys: unknown): asserts keys is string[] {\n  if (!Array.isArray(keys) || keys.some((key) => typeof key !== 'string')) {\n    throw new Error(\n      '@vercel/edge-config: Expected keys to be an array of string',\n    );\n  }\n}\n\n/**\n * Creates a deep clone of an object.\n */\nexport const clone = trace(\n  function clone<T>(value: T): T {\n    // only available since node v17.0.0\n    if (typeof structuredClone === 'function') return structuredClone<T>(value);\n\n    // poor man's polyfill for structuredClone\n    if (value === undefined) return value;\n    return JSON.parse(JSON.stringify(value)) as T;\n  },\n  { name: 'clone' },\n);\n\n/**\n * Parses internal edge config connection strings\n *\n * Internal edge config connection strings are those which are native to Vercel.\n *\n * Internal Edge Config Connection Strings look like this:\n * https://edge-config.vercel.com/<edgeConfigId>?token=<token>\n */\nfunction parseVercelConnectionString(text: string): Connection | null {\n  try {\n    const url = new URL(text);\n    if (url.host !== 'edge-config.vercel.com') return null;\n    if (url.protocol !== 'https:') return null;\n    if (!url.pathname.startsWith('/ecfg')) return null;\n\n    const id = url.pathname.split('/')[1];\n    if (!id) return null;\n\n    const token = url.searchParams.get('token');\n    if (!token || token === '') return null;\n\n    return {\n      type: 'vercel',\n      baseUrl: `https://edge-config.vercel.com/${id}`,\n      id,\n      version: '1',\n      token,\n    };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Parses info contained in connection strings.\n *\n * This works with the vercel-provided connection strings, but it also\n * works with custom connection strings.\n *\n * The reason we support custom connection strings is that it makes testing\n * edge config really straightforward. Users can provide  connection strings\n * pointing to their own servers and then either have a custom server\n * return the desired values or even intercept requests with something like\n * msw.\n *\n * To allow interception we need a custom connection string as the\n * edge-config.vercel.com connection string might not always go over\n * the network, so msw would not have a chance to intercept.\n */\n/**\n * Parses external edge config connection strings\n *\n * External edge config connection strings are those which are foreign to Vercel.\n *\n * External Edge Config Connection Strings look like this:\n * - https://example.com/?id=<edgeConfigId>&token=<token>\n * - https://example.com/<edgeConfigId>?token=<token>\n */\nfunction parseExternalConnectionString(\n  connectionString: string,\n): Connection | null {\n  try {\n    const url = new URL(connectionString);\n\n    let id: string | null = url.searchParams.get('id');\n    const token = url.searchParams.get('token');\n    const version = url.searchParams.get('version') || '1';\n\n    // try to determine id based on pathname if it wasn't provided explicitly\n    if (!id || url.pathname.startsWith('/ecfg_')) {\n      id = url.pathname.split('/')[1] || null;\n    }\n\n    if (!id || !token) return null;\n\n    // remove all search params for use as baseURL\n    url.search = '';\n\n    // try to parse as external connection string\n    return {\n      type: 'external',\n      baseUrl: url.toString(),\n      id,\n      token,\n      version,\n    };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Parse the edgeConfigId and token from an Edge Config Connection String.\n *\n * Edge Config Connection Strings usually look like this:\n * https://edge-config.vercel.com/<edgeConfigId>?token=<token>\n *\n * @param text - A potential Edge Config Connection String\n * @returns The connection parsed from the given Connection String or null.\n */\nexport function parseConnectionString(\n  connectionString: string,\n): Connection | null {\n  const connection = parseVercelConnectionString(connectionString);\n  if (connection) return connection;\n  return parseExternalConnectionString(connectionString);\n}\n","import { trace } from './tracing';\n\ninterface CachedResponseEntry {\n  etag: string;\n  response: string;\n  headers: Record<string, string>;\n  status: number;\n  time: number;\n}\n\ntype FetchOptions = Omit<RequestInit, 'headers'> & { headers?: Headers };\n\ninterface ResponseWithCachedResponse extends Response {\n  cachedResponseBody?: unknown;\n}\n\n/**\n * Creates a new response based on a cache entry\n */\nfunction createResponse(\n  cachedResponseEntry: CachedResponseEntry,\n): ResponseWithCachedResponse {\n  return new Response(cachedResponseEntry.response, {\n    headers: {\n      ...cachedResponseEntry.headers,\n      Age: String(\n        // age header may not be 0 when serving stale content, must be >= 1\n        Math.max(1, Math.floor((Date.now() - cachedResponseEntry.time) / 1000)),\n      ),\n    },\n    status: cachedResponseEntry.status,\n  });\n}\n\n/**\n * Used for bad responses like 500s\n */\nfunction createHandleStaleIfError(\n  cachedResponseEntry: CachedResponseEntry,\n  staleIfError: number | null,\n) {\n  return function handleStaleIfError(\n    response: ResponseWithCachedResponse,\n  ): ResponseWithCachedResponse {\n    switch (response.status) {\n      case 500:\n      case 502:\n      case 503:\n      case 504:\n        return typeof staleIfError === 'number' &&\n          cachedResponseEntry.time < Date.now() + staleIfError * 1000\n          ? createResponse(cachedResponseEntry)\n          : response;\n      default:\n        return response;\n    }\n  };\n}\n\n/**\n * Used on network errors which end up throwing\n */\nfunction createHandleStaleIfErrorException(\n  cachedResponseEntry: CachedResponseEntry,\n  staleIfError: number | null,\n) {\n  return function handleStaleIfError(\n    reason: unknown,\n  ): ResponseWithCachedResponse {\n    if (\n      typeof staleIfError === 'number' &&\n      cachedResponseEntry.time < Date.now() + staleIfError * 1000\n    ) {\n      return createResponse(cachedResponseEntry);\n    }\n    throw reason;\n  };\n}\n\n/**\n * A cache of request urls & auth headers and the resulting responses.\n *\n * This cache does not use Response instances as the cache value as reusing\n * responses across requests leads to issues in Cloudflare Workers.\n */\nexport const cache = new Map<string, CachedResponseEntry>();\n\nfunction extractStaleIfError(cacheControlHeader: string | null): number | null {\n  if (!cacheControlHeader) return null;\n  const matched = /stale-if-error=(?<staleIfError>\\d+)/i.exec(\n    cacheControlHeader,\n  );\n  return matched?.groups ? Number(matched.groups.staleIfError) : null;\n}\n\n/**\n * This is similar to fetch, but it also implements ETag semantics, and\n * it implmenets stale-if-error semantics.\n */\nexport const fetchWithCachedResponse = trace(\n  async function fetchWithCachedResponse(\n    url: string,\n    options: FetchOptions = {},\n  ): Promise<ResponseWithCachedResponse> {\n    const { headers: customHeaders = new Headers(), ...customOptions } =\n      options;\n    const authHeader = customHeaders.get('Authorization');\n    const cacheKey = `${url},${authHeader || ''}`;\n\n    const cachedResponseEntry = cache.get(cacheKey);\n\n    if (cachedResponseEntry) {\n      const { etag, response: cachedResponse } = cachedResponseEntry;\n      const headers = new Headers(customHeaders);\n      headers.set('If-None-Match', etag);\n\n      const staleIfError = extractStaleIfError(headers.get('Cache-Control'));\n\n      const res: ResponseWithCachedResponse = await fetch(url, {\n        ...customOptions,\n        headers,\n      }).then(\n        createHandleStaleIfError(cachedResponseEntry, staleIfError),\n        createHandleStaleIfErrorException(cachedResponseEntry, staleIfError),\n      );\n\n      if (res.status === 304) {\n        res.cachedResponseBody = JSON.parse(cachedResponse);\n        return res;\n      }\n\n      const newETag = res.headers.get('ETag');\n      if (res.ok && newETag)\n        cache.set(cacheKey, {\n          etag: newETag,\n          response: await res.clone().text(),\n          headers: Object.fromEntries(res.headers.entries()),\n          status: res.status,\n          time: Date.now(),\n        });\n      return res;\n    }\n\n    const res = await fetch(url, options);\n    const etag = res.headers.get('ETag');\n    if (res.ok && etag) {\n      cache.set(cacheKey, {\n        etag,\n        response: await res.clone().text(),\n        headers: Object.fromEntries(res.headers.entries()),\n        status: res.status,\n        time: Date.now(),\n      });\n    }\n\n    return res;\n  },\n  {\n    name: 'fetchWithCachedResponse',\n    attributesSuccess(result) {\n      return {\n        status: result.status,\n      };\n    },\n  },\n);\n"]}